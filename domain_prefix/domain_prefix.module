<?php
// $Id$

/** 
* @file
* Interface for selective table prefixing for use with Domain Access.
* For this module to work correctly, you will need to follow the INSTALL.txt 
* instructions for editing your settings.php file.
*/

/**
 * Constant definitions for the various actions.
 */
define(DOMAIN_PREFIX_IGNORE, 1); 
define(DOMAIN_PREFIX_CREATE, 2);
define(DOMAIN_PREFIX_COPY, 4);
define(DOMAIN_PREFIX_DROP, 8);

/**
 * Implements hook_menu()
 *
 * @ingroup drupal
 */
function domain_prefix_menu($may_cache) {
  $items = array();
  if ($may_cache) {
    $items[] = array(
      'title' => t('Table prefixing'),
      'path' => 'admin/build/domain/prefix',
      'access' => user_access('prefix tables'),
      'type' => MENU_LOCAL_TASK,
      'callback' => 'drupal_get_form',
      'callback arguments' => array('domain_prefix_configure_form')      
    );    
  }
  else {
    $items[] = array(
      'title' => t('Domain prefix settings'),
      'path' => 'admin/build/domain/prefix/'. arg(4),
      'access' => user_access('prefix tables'),
      'type' => MENU_CALLBACK,
      'callback' => 'drupal_get_form',
      'callback arguments' => array('domain_prefix_form', arg(4))      
    );
    $items[] = array(
      'title' => t('Domain prefix update'),
      'path' => 'domain_prefix_update',
      'access' => user_access('prefix tables'),
      'type' => MENU_CALLBACK,
      'callback' => 'domain_prefix_update',
    );    
  }
  return $items;
}

/**
 * Implements hook_perm
 */
function domain_prefix_perm() {
  return array('prefix tables');
}

/**
 * Check for existing table prefixing.
 */
function domain_prefix_get_prefix() {
  global $db_prefix;
  // Check for existing table prefixing.
  $prefix = NULL;
  if (!empty($db_prefix)) {
    if (is_array($db_prefix)) {
      $prefix = $db_prefix['default'];
    }
    else {
      $prefix = $db_prefix;
    }
  }  
  return $prefix;
}

/**
 * Get the tables with the active prefix
 */
function domain_prefix_get_tables($prefix = NULL) {
  // Check for default prefix settings.
  if (empty($prefix)) {
    $prefix = domain_prefix_get_prefix();
  }
  // This currently won't work in pgsql
  if (empty($prefix)) {
    $result = db_query("SHOW TABLES");
  }
  else {
    $result = db_query("SHOW TABLES LIKE '$prefix%%'");  
  }
  $tables = array();
  $disallow = domain_prefix_disallow();
  while ($data = db_fetch_array($result)) {
    // Chop table prefixes.
    $str = current($data);
    if (!empty($prefix)) {
      $str = preg_replace('/'. $prefix .'/', '', $str, 1);
    }
    if (!in_array($str, $disallow) && substr($str, 0, 7) != 'domain_') { 
      $tables[$str]['tablename'] = $str;
      $tables[$str]['module'] = domain_prefix_module_lookup($str);
    }  
  }
  // Sort them by module
  uasort($tables, '_domain_prefix_sort');
  return $tables;
}

/**
 * Helper sort function
 */
function _domain_prefix_sort($a, $b) {
  $_a = str_replace('_', '', $a['tablename']);
  $_b = str_replace('_', '', $b['tablename']);  
  if ($a['module'] == $b['module']) {
    return strcmp($_a, $_b);
  }
  return strcmp($a['module'], $b['module']);
}

/**
 * FormsAPI for generating the configuration form
 */
function domain_prefix_configure_form() {
  drupal_set_title(t('Default table prefix settings'));
  // We must be on the root domain!
  $default = domain_default();
  domain_goto($default);
  // Get the tables for the root installation.
  $tables = domain_prefix_get_tables($prefix);
  // Remove the disallowed tables.
  $disallow = domain_prefix_disallow();
  // Get the current settings.
  $settings = unserialize(variable_get('domain_prefix', NULL));
  $form = array();
  $form['domain'] = array(
    '#type' => 'fieldset',
    '#title' => t('Domain creation rules'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE
  );
  $form['domain']['domain_prefix_options'] = array(
    '#type' => 'radios',
    '#title' => t('Domain creation options'),
    '#description' => t('Determines what actions to take when creating new domain records.'),
    '#options' => array(1 => t('Generate tables as defined below'), 0 => t('Do not generate any tables')),
    '#default_value' => variable_get('domain_prefix_options', 1),
    '#required' => TRUE
  );
  $last = ''; // Flag for module grouping.
  foreach ($tables as $table => $info) {
    if (!in_array($table, $disallow) && substr($table, 0, 7) != 'domain_') {
      if (empty($settings[$table])) {
        $settings[$table] = DOMAIN_PREFIX_IGNORE;
      }
      $module = $info['module'];
      if ($last != $module) {
        $last = $module;
      }
      else {
        $module = '';
      }      
      $options = array();
      $options[DOMAIN_PREFIX_IGNORE] = t('ignore');
      $options[DOMAIN_PREFIX_CREATE] = t('create');      
      $options[DOMAIN_PREFIX_COPY] = t('copy');
      $form['domain_prefix'][$table] = array(
        '#type' => 'radios',
        '#title' => $table,
        '#options' => $options,
        '#default_value' => $settings[$table],
        '#description' => $module        
      ); 
    }  
  }
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save prefix settings'),
  );
  $form['restore'] = array(
    '#type' => 'submit',
    '#value' => t('Restore defaults'),
  );  
  return $form;
}

/**
 * Implements hook_domainlinks()
 *
 * @ingroup prefix
 */
function domain_prefix_domainlinks($domain) {
  $links[] = array(
    'title' => t('tables'),
    'path' => 'admin/build/domain/prefix/'. $domain['domain_id']
  );
  return $links;
}

/**
 * FormsAPI
 */
function domain_prefix_configure_form_submit($form_id, $form_values) {
  // Throw away what we don't need.
  $options = $form_values['domain_prefix_options'];
  $unset = array('op', 'submit', 'restore', 'form_token', 'form_id', 'domain_prefix_options');
  $data = $form_values;
  foreach ($unset as $key) {
    unset($data[$key]);
  }
  if ($form_values['op'] == $form_values['restore']) {
    variable_del('domain_prefix');
    drupal_set_message(t('Default prefix settings reset.'));
  }
  else {
    $settings = serialize($data);
    variable_set('domain_prefix', $settings);
    drupal_set_message(t('Default prefix settings changed.'));
  }
  variable_set('domain_prefix_options', $options);
}


/**
 * FormsAPI
 */
function theme_domain_prefix_configure_form($form) {
  $output = t('<p>These settings control advanced functions.  Please read the documentation carefully.</p>');
  $header = array(t('Table'), t('Ignore'), t('Create'), t('Copy'));
  if ($form['prefix_theme']['#value'] > 0) {
    $header[] = t('Drop');
    unset($form['prefix_theme']);
  }
  $output = drupal_render($form['domain']);
  foreach (element_children($form['domain_prefix']) as $key) {
    if ($form['domain_prefix'][$key]['#description']) {
      $rows[] = array('<b>'. $form['domain_prefix'][$key]['#description'] .'</b>', array('', 'colspan' => 4));  
    }
    $row = array();
    $row[] = ' - '. $form['domain_prefix'][$key]['#title'];
    foreach (element_children($form['domain_prefix'][$key]) as $option) {
      $row[] = drupal_render($form['domain_prefix'][$key][$option]);    
    }  
    // throw this away
    $render = drupal_render($form['domain_prefix'][$key]);
    $rows[] = $row;
  }
  $output .= theme('table', $header, $rows);
  $output .= drupal_render($form);
  return $output;
}

/**
 * The table prefixing page for a domain.
 */
function domain_prefix_form($domain_id) {
  // We must be on the root domain!
  $default = domain_default();
  domain_goto($default);
  $domain = domain_lookup($domain_id);
  drupal_set_title(t('Table prefixing for !domain', array('!domain' => $domain['sitename'])));
  // Remove the disallowed tables.
  $disallow = domain_prefix_disallow();
  
  // Get the default table set and settings.
  $default = domain_prefix_get_tables();
  $settings = unserialize(variable_get('domain_prefix', NULL));
  if (empty($settings)) {
    drupal_set_message(t('There are no default settings configured.'));
  }
  
  // Get the stored table data for this domain.
  $tables = domain_prefix_lookup($domain_id);
  $submit = t('Update domain tables');
  if (empty($tables)) {
    if (!$form_values['execute']) {
      drupal_set_message(t('The table creation sequence has not run for this domain.'));
    }  
    $submit = t('Generate domain tables');
    $table_options = $default;
  }
  else {
    $table_options = array();
    $settings = array();
    foreach ($tables as $table) {
      $table_options[$table['tablename']] = $table;
      $settings[$table['tablename']] = $table['status'];
    }
    $table_options = array_merge($default, $table_options);
  }
  // Sort them by module
  uasort($table_options, '_domain_prefix_sort');  
  // All tables are prefixed as 'domain_#_'
  $prefix = 'domain_'. $domain_id .'_';
  // Generate the form.
  $form = array();
  $delete_flag = 0; // Flag for the theme function delete column
  $last = ''; // Flag for module groupings.
  foreach ($table_options as $table => $info) {
    if (!in_array($table, $disallow)) {
      if (empty($settings[$table])) {
        $settings[$table] = DOMAIN_PREFIX_IGNORE;
      }
      $options = array();
      $options[DOMAIN_PREFIX_IGNORE] = t('ignore');
      $options[DOMAIN_PREFIX_CREATE] = t('create');      
      $options[DOMAIN_PREFIX_COPY] = t('copy');
      if ($settings[$table] > 0) {
        $exists = domain_prefix_table_exists($prefix, $table);
        if ($exists > 0) {
          $options[DOMAIN_PREFIX_DROP] = t('drop');
          $delete_flag++;
        }  
      }
      $module = $info['module'];
      if ($last != $module) {
        $last = $module;
      }
      else {
        $module = '';
      }
      $form['domain_prefix'][$table] = array(
        '#type' => 'radios',
        '#title' => $table,
        '#options' => $options,
        '#default_value' => $settings[$table],
        '#description' => $module
      ); 
    }  
  }
  $form['#theme'] = 'domain_prefix_configure_form';
  $form['prefix_theme'] = array('#type' => 'value', '#value' => $delete_flag);
  $form['domain_id'] = array('#type' => 'value', '#value' => $domain_id);  
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => $submit
  );
  return $form;
}

/**
 * Does a table exist -- we use this to bypass Drupal's default table prefixing check.
 */
function domain_prefix_table_exists($prefix, $table) {
  global $db_type;
  $string = db_escape_table($prefix . $table);
  switch($db_type) {
    case 'pgsql':
      $query = "SELECT relname FROM pg_class WHERE relname = '%s'";
      break;
    default:
      $query = "SHOW TABLES LIKE '%s'";
      break;
  }
  return db_num_rows(db_query($query, $string));
}

/**
 * FormsAPI
 */
function domain_prefix_form_submit($form_id, $form_values) {
  // Throw away what we don't need.
  $prefix = 'domain_'. $form_values['domain_id'] .'_';
  $unset = array('prefix_theme', 'domain_id', 'op', 'submit', 'restore', 'form_token', 'form_id', 'execute');
  $data = $form_values;
  foreach ($unset as $key) {
    unset($data[$key]);
  }

  // Delete existing records, but get the existing values first.
  $current = domain_prefix_lookup($form_values['domain_id']);
  db_query("DELETE FROM {domain_prefix} WHERE domain_id = %d", $form_values['domain_id']);
  foreach ($data as $key => $value) {
    $update = FALSE;
    if (empty($value)) {
      $value = DOMAIN_PREFIX_IGNORE;
      $update = TRUE;
    }
    $newtable = db_escape_table($prefix . $key);
    $module = domain_prefix_module_lookup($key);
    $exists = domain_prefix_table_exists($prefix, $key);
    $oldtable = db_escape_table($key);
    if ($value == DOMAIN_PREFIX_CREATE) {
      if (!$exists) {
        db_query("CREATE TABLE %s LIKE %s", $newtable, $oldtable);
        drupal_set_message(t('!string table created.', array('!string' => $newtable)));
        $update = TRUE;
      }
      else if ($current[$oldtable]['status'] == DOMAIN_PREFIX_COPY) {
        drupal_set_message(t('!string table cannot be created, since it already exists.', array('!string' => $newtable)));
      }
    }
    else if ($value == DOMAIN_PREFIX_COPY) {
      if (!$exists) {
        db_query("CREATE TABLE %s LIKE %s", $newtable, $oldtable);
        db_query("INSERT INTO %s SELECT * FROM %s", $newtable, $oldtable);
        drupal_set_message(t('!string table copied.', array('!string' => $newtable)));
        $update = TRUE;      
      }
      else if ($current[$oldtable]['status'] == DOMAIN_PREFIX_CREATE) {
        drupal_set_message(t('!string table cannot be copied, since it already exists.', array('!string' => $newtable)));
      }
    }
    else if ($value == DOMAIN_PREFIX_DROP) {
      if ($exists > 0) {
        db_query("DROP TABLE %s", $newtable);
        $value = DOMAIN_PREFIX_IGNORE;
        drupal_set_message(t('!string table dropped.', array('!string' => $newtable)));      
        $update = TRUE;      
      }  
      else {
        drupal_set_message(t('!string table does not exist.', array('!string' => $newtable)));
      }
    }
    // Update our records.
    if (!$update && $value != 1) {
      $value = $current[$oldtable]['status'];
    }
    db_query("INSERT INTO {domain_prefix} (domain_id, status, tablename, module) VALUES (%d, %d, '%s', '%s')", $form_values['domain_id'], $value, $key, $module);
  }
}

/**
 * Derive a module name from the table name
 *
 * In future, SchemaAPI will do this for us.
 * For now, we will have to map core tables.
 */
function domain_prefix_module_lookup($table) {
  $match = explode('_', $table);
  $module = $match[0];
  switch ($table) {
    default:
      break;
    case 'boxes':
      $module = 'blocks';
      break;
    case 'file_revisions':  
      $module = 'files';
      break;
    case 'cache_menu':
      $module = 'menu';
      break;
    case 'filter_formats':
      $module = 'filters';
      break;
    case 'access':      
    case 'permission':
    case 'role':
    case 'users':
    case 'users_roles':
      $module = 'users';
      break;
    case 'url_alias':
      $module = 'path';
      break;
    case 'variable':
      $module = 'cache';
      break;
    case 'client':
    case 'client_system':
      $module = 'drupal';
      break;
    case 'accesslog':
      $module = 'statistics';
      break;
     case 'term_data':
     case 'term_hierarchy':
     case 'term_node':
     case 'term_relation':
     case 'term_synonym':
      $module = 'taxonomy';
      break;
  }
  return $module;
}

/**
 * Lookup stored table information for a domain
 */
function domain_prefix_lookup($domain_id) {
  static $domain_prefix;
  if (!isset($domain_prefix[$domain_id])) {
    $domain_prefix[$domain_id] = array();
    $result = db_query("SELECT domain_id, status, tablename, module FROM {domain_prefix} WHERE domain_id = %d", $domain_id);
    while ($data = db_fetch_array($result)) {
      $domain_prefix[$domain_id][$data['tablename']] = $data;
    }  
  }
  return $domain_prefix[$domain_id];
}

/**
 * Names of tables explicitly not allowed to be copied
 */
function domain_prefix_disallow() {
  return array(
    'domain',
    'domain_conf',
    'domain_prefix',
    'domain_theme',
  );
}

/**
 * Creating a record, make the tables
 */
function domain_prefix_domainupdate($op, $domain = array(), $edit = array()) {
  switch ($op) {
    case 'create':
      $rule = variable_get('domain_prefix_options', 1);
      if ($rule) {
        $settings = unserialize(variable_get('domain_prefix', NULL));    
        if (!empty($settings)) {
          $form_values = array();
          $settings['domain_id'] = $domain['domain_id'];
          $settings['execute'] = TRUE;
          $form_values['domain_prefix'] = $settings;
          drupal_execute('domain_prefix_form', $settings, $domain['domain_id']);
        }
      }
      break;
    case 'delete':
      domain_prefix_drop_records($domain['domain_id']);
      break;
  }
}

/**
 * Drop tables
 */
function domain_prefix_drop_records($domain_id) {
  $result = db_query("SELECT tablename FROM {domain_prefix} WHERE domain_id = %d AND status > 1", $domain_id);
  $prefix = 'domain_'. $domain_id .'_';
  while ($tables = db_fetch_array($result)) {
    $table = db_escape_table($prefix . $tables['tablename']);
    $exists = domain_prefix_table_exists($prefix, $tables['tablename']);  
    if ($exists > 0) {
      db_query("DROP TABLE %s", $table);
      drupal_set_message(t('!string table dropped.', array('!string' => $table)));      
    }  
  }
  db_query("DELETE FROM {domain_prefix} WHERE domain_id = %d", $domain_id);
}